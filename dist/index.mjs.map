{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import * as xlsx from \"xlsx\";\r\nimport * as fs from \"fs\";\r\nimport path from \"path\";\r\n\r\ninterface Filter {\r\n  [key: string]: string;\r\n}\r\n\r\ninterface ConvertOptions {\r\n  inputFile: string;\r\n  outputDir: string;\r\n  outputFilename?: string;\r\n  filter?: Filter;\r\n}\r\n\r\ninterface ConvertResult {\r\n  outputPath: string;\r\n}\r\n\r\nexport async function convertXlsxToCsv(\r\n  options: ConvertOptions,\r\n): Promise<ConvertResult> {\r\n  return new Promise((resolve, reject) => {\r\n    try {\r\n      const { inputFile, outputDir, outputFilename, filter } = options;\r\n\r\n      // check if the file is an XLSX file\r\n      if (!inputFile.endsWith(\".xlsx\")) {\r\n        throw new Error(\"The input file must be an XLSX file\");\r\n      }\r\n\r\n      // read the XLSX file and get the first worksheet\r\n      const workbook = xlsx.readFile(inputFile);\r\n      const sheetName = workbook.SheetNames[0];\r\n      const worksheet = workbook.Sheets[sheetName];\r\n\r\n      // convert the XLSX to CSV\r\n      let csv = xlsx.utils.sheet_to_csv(worksheet);\r\n\r\n      // if filter is provided, rename the header row and remove unwanted columns\r\n      if (filter) {\r\n        // split the CSV by line\r\n        const lines = csv.split(\"\\n\");\r\n\r\n        // get the original header row and split by comma\r\n        const header = lines[0].split(\",\");\r\n\r\n        // create a new header row and a map of column indices to keep\r\n        let newHeader = \"\";\r\n        const columnsToKeep = new Map<number, boolean>();\r\n\r\n        // iterate over the original header and check if it matches any key in the filter object\r\n        for (let col = 0; col < header.length; col++) {\r\n          const key = header[col];\r\n          if (filter.hasOwnProperty(key)) {\r\n            // if yes, append the corresponding value to the new header and mark the column index to keep\r\n            newHeader += `${filter[key]},`;\r\n            columnsToKeep.set(col, true);\r\n            if (key !== filter[key]) {\r\n              console.info(\r\n                `The column \"${key}\" has been renamed to \"${filter[key]}\"`,\r\n              );\r\n            }\r\n          } else {\r\n            // if no, warn to console and skip the column index\r\n            console.info(\r\n              `The column \"${key}\" is not listed in the filter object and will be removed`,\r\n            );\r\n          }\r\n        }\r\n\r\n        // remove the trailing comma from the new header\r\n        newHeader = newHeader.slice(0, -1);\r\n\r\n        console.info(`The header has been updated to: ${newHeader}`);\r\n\r\n        // create a new CSV with only the columns to keep\r\n        let newCsv = \"\";\r\n\r\n        // iterate over the lines and split by comma\r\n        for (let row = 0; row < lines.length; row++) {\r\n          // replace the first line of the CSV with the new header\r\n          if (row === 0) {\r\n            newCsv += `${newHeader}\\n`;\r\n            continue;\r\n          }\r\n\r\n          const values = lines[row].split(\",\");\r\n\r\n          // create a new line with only the values from the columns to keep\r\n          let newLine = \"\";\r\n\r\n          // iterate over the values and check the column index\r\n          for (let i = 0; i < values.length; i++) {\r\n            if (columnsToKeep.has(i)) {\r\n              // if the column index is marked to keep, append the value to the new line\r\n              newLine += `${values[i]},`;\r\n            }\r\n          }\r\n\r\n          // remove the trailing comma from the new line\r\n          newLine = newLine.slice(0, -1);\r\n\r\n          // append the new line to the new CSV\r\n          newCsv += `${newLine}\\n`;\r\n        }\r\n\r\n        // replace the CSV with the new CSV\r\n        csv = newCsv;\r\n      }\r\n\r\n      // create a new file\r\n      const outputFile = `${path.join(\r\n        outputDir,\r\n        outputFilename ?? path.basename(inputFile, \".xlsx\"),\r\n      )}.csv`;\r\n\r\n      // write the CSV content to the new file\r\n      fs.writeFileSync(outputFile, csv);\r\n\r\n      // get the output path of the new file\r\n      const outputPath = path.resolve(outputFile);\r\n\r\n      console.info(`Output file: ${outputPath}`);\r\n\r\n      resolve({\r\n        outputPath: outputPath,\r\n      });\r\n    } catch (error) {\r\n      reject(error);\r\n    }\r\n  });\r\n}\r\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,YAAY,UAAU;AACtB,YAAY,QAAQ;AACpB,OAAO,UAAU;AAiBjB,SAAsB,iBACpB,SACwB;AAAA;AACxB,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,UAAI;AACF,cAAM,EAAE,WAAW,WAAW,gBAAgB,OAAO,IAAI;AAGzD,YAAI,CAAC,UAAU,SAAS,OAAO,GAAG;AAChC,gBAAM,IAAI,MAAM,qCAAqC;AAAA,QACvD;AAGA,cAAM,WAAgB,cAAS,SAAS;AACxC,cAAM,YAAY,SAAS,WAAW,CAAC;AACvC,cAAM,YAAY,SAAS,OAAO,SAAS;AAG3C,YAAI,MAAW,WAAM,aAAa,SAAS;AAG3C,YAAI,QAAQ;AAEV,gBAAM,QAAQ,IAAI,MAAM,IAAI;AAG5B,gBAAM,SAAS,MAAM,CAAC,EAAE,MAAM,GAAG;AAGjC,cAAI,YAAY;AAChB,gBAAM,gBAAgB,oBAAI,IAAqB;AAG/C,mBAAS,MAAM,GAAG,MAAM,OAAO,QAAQ,OAAO;AAC5C,kBAAM,MAAM,OAAO,GAAG;AACtB,gBAAI,OAAO,eAAe,GAAG,GAAG;AAE9B,2BAAa,GAAG,OAAO,GAAG,CAAC;AAC3B,4BAAc,IAAI,KAAK,IAAI;AAC3B,kBAAI,QAAQ,OAAO,GAAG,GAAG;AACvB,wBAAQ;AAAA,kBACN,eAAe,GAAG,0BAA0B,OAAO,GAAG,CAAC;AAAA,gBACzD;AAAA,cACF;AAAA,YACF,OAAO;AAEL,sBAAQ;AAAA,gBACN,eAAe,GAAG;AAAA,cACpB;AAAA,YACF;AAAA,UACF;AAGA,sBAAY,UAAU,MAAM,GAAG,EAAE;AAEjC,kBAAQ,KAAK,mCAAmC,SAAS,EAAE;AAG3D,cAAI,SAAS;AAGb,mBAAS,MAAM,GAAG,MAAM,MAAM,QAAQ,OAAO;AAE3C,gBAAI,QAAQ,GAAG;AACb,wBAAU,GAAG,SAAS;AAAA;AACtB;AAAA,YACF;AAEA,kBAAM,SAAS,MAAM,GAAG,EAAE,MAAM,GAAG;AAGnC,gBAAI,UAAU;AAGd,qBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,kBAAI,cAAc,IAAI,CAAC,GAAG;AAExB,2BAAW,GAAG,OAAO,CAAC,CAAC;AAAA,cACzB;AAAA,YACF;AAGA,sBAAU,QAAQ,MAAM,GAAG,EAAE;AAG7B,sBAAU,GAAG,OAAO;AAAA;AAAA,UACtB;AAGA,gBAAM;AAAA,QACR;AAGA,cAAM,aAAa,GAAG,KAAK;AAAA,UACzB;AAAA,UACA,0CAAkB,KAAK,SAAS,WAAW,OAAO;AAAA,QACpD,CAAC;AAGD,QAAG,iBAAc,YAAY,GAAG;AAGhC,cAAM,aAAa,KAAK,QAAQ,UAAU;AAE1C,gBAAQ,KAAK,gBAAgB,UAAU,EAAE;AAEzC,gBAAQ;AAAA,UACN;AAAA,QACF,CAAC;AAAA,MACH,SAAS,OAAO;AACd,eAAO,KAAK;AAAA,MACd;AAAA,IACF,CAAC;AAAA,EACH;AAAA;","names":[]}